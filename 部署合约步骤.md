# 📝 立即部署 NFT 合约 - 详细步骤

## 🎯 问题说明

**当前状态**: 合约地址是占位符 `0x0000000000000000000000000000000000000000`  
**结果**: 交易发送到零地址，没有实际铸造 NFT ❌

**需要做的**: 部署真正的 NFT 合约到 Sepolia 测试网 ✅

---

## 🚀 使用 Remix IDE 部署（5分钟完成）

### 步骤 1: 准备工作

1. **确保 MetaMask 已安装并连接到 Sepolia 测试网**
   - 打开 MetaMask
   - 点击网络选择器 → 选择 "Sepolia test network"
   
2. **确保有测试币**（至少 0.01 ETH）
   - 如果没有，访问水龙头：https://sepoliafaucet.com/
   - 输入您的钱包地址获取测试币

### 步骤 2: 打开 Remix IDE

访问：**https://remix.ethereum.org/**

### 步骤 3: 创建合约文件

1. 在左侧 "File Explorer" 中
2. 右键点击 `contracts` 文件夹 → "New File"
3. 文件名输入：`MemoryToken.sol`
4. 将下面的合约代码复制粘贴进去：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title MemoryToken
 * @dev NFT合约，用于铸造人文故事记忆代币
 * 支持用户自己铸造（公开铸造）和管理员铸造
 */
contract MemoryToken is ERC721, ERC721URIStorage, Ownable {
    uint256 private _tokenIdCounter;
    
    // 铸造费用（设置为0实现免费铸造）
    uint256 public mintPrice = 0;
    
    // 是否启用公开铸造
    bool public publicMintEnabled = true;
    
    // 事件：当新的NFT被铸造时触发
    event TokenMinted(address indexed recipient, uint256 indexed tokenId, string tokenURI);

    constructor() ERC721("MemoryToken", "MEMORY") Ownable(msg.sender) {
        _tokenIdCounter = 0;
    }

    /**
     * @dev 用户自己铸造NFT（公开铸造）
     * @param tokenURI NFT的元数据URI
     */
    function mint(string memory tokenURI) public payable returns (uint256) {
        require(publicMintEnabled, "Public minting is disabled");
        require(msg.value >= mintPrice, "Insufficient payment");
        require(bytes(tokenURI).length > 0, "Token URI cannot be empty");
        
        uint256 tokenId = _tokenIdCounter;
        _tokenIdCounter++;
        
        _safeMint(msg.sender, tokenId);
        _setTokenURI(tokenId, tokenURI);
        
        emit TokenMinted(msg.sender, tokenId, tokenURI);
        return tokenId;
    }

    /**
     * @dev 管理员铸造NFT给指定地址（仅合约所有者）
     * @param recipient 接收NFT的地址
     * @param tokenURI NFT的元数据URI
     */
    function mintToken(address recipient, string memory tokenURI) 
        public 
        onlyOwner 
        returns (uint256) 
    {
        require(recipient != address(0), "Invalid recipient address");
        require(bytes(tokenURI).length > 0, "Token URI cannot be empty");

        uint256 tokenId = _tokenIdCounter;
        _tokenIdCounter++;

        _safeMint(recipient, tokenId);
        _setTokenURI(tokenId, tokenURI);

        emit TokenMinted(recipient, tokenId, tokenURI);
        return tokenId;
    }

    /**
     * @dev 设置铸造价格（仅合约所有者）
     */
    function setMintPrice(uint256 _price) public onlyOwner {
        mintPrice = _price;
    }

    /**
     * @dev 启用或禁用公开铸造（仅合约所有者）
     */
    function setPublicMintEnabled(bool _enabled) public onlyOwner {
        publicMintEnabled = _enabled;
    }

    /**
     * @dev 提取合约余额（仅合约所有者）
     */
    function withdraw() public onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }

    /**
     * @dev 获取当前Token计数
     */
    function getCurrentTokenId() public view returns (uint256) {
        return _tokenIdCounter;
    }

    /**
     * @dev 获取用户拥有的所有NFT ID
     */
    function tokensOfOwner(address _owner) public view returns (uint256[] memory) {
        uint256 tokenCount = balanceOf(_owner);
        uint256[] memory tokenIds = new uint256[](tokenCount);
        uint256 index = 0;
        
        for (uint256 i = 0; i < _tokenIdCounter; i++) {
            if (_ownerOf(i) == _owner) {
                tokenIds[index] = i;
                index++;
            }
        }
        
        return tokenIds;
    }

    // 以下函数为必需的override
    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
```

### 步骤 4: 编译合约

1. 点击左侧的 **"Solidity Compiler"** 图标（第二个图标）
2. 选择编译器版本：**0.8.20** 或更高（如 0.8.27）
3. 点击蓝色的 **"Compile MemoryToken.sol"** 按钮
4. 等待编译完成（应该显示绿色对勾 ✅）

### 步骤 5: 部署合约

1. 点击左侧的 **"Deploy & Run Transactions"** 图标（第三个图标）
2. **Environment** 选择：`Injected Provider - MetaMask`
   - MetaMask 会弹出连接请求
   - 点击 "Next" → "Connect"
3. 确认显示的账户是您的 MetaMask 账户
4. 确认网络是 **Sepolia (11155111)**
5. **Contract** 下拉框选择：`MemoryToken - contracts/MemoryToken.sol`
6. 点击橙色的 **"Deploy"** 按钮
7. **MetaMask 会弹出交易确认窗口**：
   - 检查 Gas 费用（大约 0.005-0.01 ETH）
   - 点击 **"确认"** 发送交易
8. 等待交易确认（10-30 秒）

### 步骤 6: 复制合约地址

1. 部署成功后，在底部 **"Deployed Contracts"** 区域会出现您的合约
2. 看到类似：`MEMORYTOKEN AT 0xABC123...` 
3. 点击合约地址旁边的 **📋 复制按钮**
4. **保存这个地址！**（格式类似：`0x1234567890abcdef1234567890abcdef12345678`）

---

## 🔧 步骤 7: 更新项目配置

### 打开 `.env` 文件

```bash
nano /Users/rebeccawang/web3/dda/DAA_MVP/.env
```

### 更新合约地址

找到这一行：
```
CONTRACT_ADDRESS=0x0000000000000000000000000000000000000000
```

替换为您刚才复制的真实合约地址：
```
CONTRACT_ADDRESS=0x您刚才复制的合约地址
```

### 保存文件

- 按 `Ctrl + O` 保存
- 按 `Enter` 确认
- 按 `Ctrl + X` 退出

---

## ✅ 步骤 8: 重启服务器

服务器会自动重新加载配置，或者手动重启：

在终端按 `Ctrl + C` 停止服务器，然后重新启动。

---

## 🎉 步骤 9: 测试铸造

1. 访问 **http://localhost:5001**
2. 点击 **"🔐 连接钱包"**
3. 在 MetaMask 中授权连接
4. 输入一个故事并评估
5. 点击 **"🎨 铸造 NFT"**
6. 在 MetaMask 中确认交易
7. 等待成功！

这次您会真正收到 NFT！ 🎊

---

## 📊 验证您的 NFT

### 在 Remix 中验证

1. 在 "Deployed Contracts" 中展开您的合约
2. 找到 `tokensOfOwner` 函数
3. 输入您的钱包地址
4. 点击 "call"
5. 应该显示您拥有的 NFT ID 数组

### 在区块浏览器验证

1. 访问：https://sepolia.etherscan.io/
2. 搜索您的合约地址
3. 查看 "Contract" → "Read Contract"
4. 调用 `balanceOf` 查看您的 NFT 数量

### 在 OpenSea 测试网查看

1. 访问：https://testnets.opensea.io/
2. 连接钱包
3. 查看 "Profile"
4. 应该能看到您的 MemoryToken NFT！

---

## 🎯 完成检查清单

- [ ] MetaMask 已安装并连接到 Sepolia
- [ ] 钱包有测试币（≥ 0.01 ETH）
- [ ] 在 Remix 中创建并编译合约
- [ ] 成功部署合约
- [ ] 复制了合约地址
- [ ] 更新了 `.env` 文件中的 `CONTRACT_ADDRESS`
- [ ] 重启了服务器
- [ ] 测试铸造成功并收到 NFT

---

## ❓ 如果遇到问题

**编译错误？**
- 确保选择了正确的 Solidity 版本（≥ 0.8.20）
- 确保代码完整复制

**部署失败？**
- 检查 MetaMask 是否在 Sepolia 网络
- 确保有足够的测试币
- 刷新 Remix 页面重试

**铸造失败？**
- 确保 `.env` 中的合约地址正确
- 确保已重启服务器
- 检查浏览器控制台的错误信息

---

**现在开始部署吧！** 🚀

完成后告诉我合约地址，我会帮您验证！

